#!/usr/bin/env python
# -*- coding: utf-8 -*-


"""
Tempest is a really ridiculously stupidly simple templating engine. Intended
for building fast static websites, but can be used for any text substitution
needs.

Run tempest -h for help.

"""

import os
import sys
from string import Template
import json
import argparse
import collections
from collections import OrderedDict


class TemplateString(Template):
    delimiter = '$$'

class TemplateFile(Template):
    delimiter = '##'

def message(type, err_code, text):
    if type == "info":
        sys.stderr.write("Info: %s\n", text)
    elif type == "error" or (type == "warn" and "error" in args.warnings):
        if type == "warn" and ("no-" + err_code) in args.warnings:
            return
        sys.stderr.write("Error (%s): %s Terminating.\n" % (err_code, text))
        sys.exit(-1)
    elif type == "warn":
        if ("no-" + err_code) in args.warnings:
            return
        sys.stderr.write("Warning (%s): %s\n" % (err_code,text))
    elif type == "debug":
        if args.verbose:
            sys.stderr.write("Debug: %s\n" % text)
    else:
        print_message("error", "internal", "Unknown print message type '%s'." % type)

def load_file(f):
    message("debug", None, "  Opening %s..." % f)
    f = open(f)
    result = f.read()
    return result

def load_temp(t):
    message("debug", None, "Loading template...")
    return load_file(t)

def run_subs(temp, dict):
    message("debug", None, "Doing substitutions...")
    try:
        s = TemplateString(temp)
        temp = s.substitute(dict)
    except KeyError as e:
        message("error", "string-sub", "String substitution '%s' not found." % e.message)
    try:
        f = TemplateFile(temp)
        result = f.substitute(dict)
    except KeyError as e:
        message("error", "file-sub", "File insertion '%s' not found." % e.message)

    return result

def load_subs_file(file,incl_dirs,dict):
    if os.path.exists(file):
        file_str = load_file(file)
        return run_subs(file_str,dict)

    for incl_dir in incl_dirs:
        incl_dir += "/" if incl_dir[-1] != "/" else ""
        file_path = incl_dir + file
        if os.path.exists(file_path):
            file_str = load_file(file_path)
            return run_subs(file_str,dict)

    message("warn", "file-not-found", "Include file '%s' not found." % incl)

def load_incl(incl,incl_dirs):
    if os.path.exists(incl):
        return load_file(incl)

    for incl_dir in incl_dirs:
        incl_dir += "/" if incl_dir[-1] != "/" else ""
        incl_path = incl_dir + incl
        if os.path.exists(incl_path):
            return load_file(incl_path)

    message("warn", "file-not-found", "Include file '%s' not found." % incl)


def add_value(id,val,result,incl_dirs,has_context):
        if id in result:
            if has_context:
                message("warn", "overwrite-context", "Identifer '%s' already defined in global scope. Conext will overwrite." % id)
            else:
                message("warn", "overwrite", "Identifer '%s' already defined. Overwriting." % id)

        if "##" in val:
            result[id] = load_subs_file(val[2:],incl_dirs,result)
        else:
            result[id] = val

def load_dict(args_incls, args_incl_dirs, args_defs, contexts):
    result = {}
    message("debug", None, "Loading dictonaries...")
    for arg_def in args_defs:
        define = arg_def.split("=")
        if len(define) < 2:
            message("warn", "define-fail", "Definition failure '%s'. Definitions must be in the form identifier=value." % args_defs)
            continue

        id = define[0]
        val = "=".join(define[1:])
        add_value(id,val,result, args_incl_dirs, False)

    for args_incl in args_incls:
        incl = load_incl(args_incl, args_incl_dirs)
        config = json.loads(incl.decode('utf-8'), object_pairs_hook=OrderedDict)
        for node in config:
            message("debug",None,"Looking at node %s" % node)
            if isinstance(config[node], collections.Mapping) and node in contexts:
                for sub_node in config[node]:
                    add_value(sub_node,config[node][sub_node],result, args_incl_dirs, True)
            else:
                add_value(node,config[node],result, args_incl_dirs, False)

    return result


def write_out(result, args_out):
    message("debug", None, "Saving output...")
    message("debug", None, "  Writing to '%s'..." % args_out )
    out = open(args_out,"w")
    out.write(result)
    out.close()
    return


# Real fun starts here....
parser = argparse.ArgumentParser(description='A really ridiculously stupidly simple templating engine.',
 epilog="example: tempest -t my.t -d values.json -o my.html\n\n")

parser.add_argument(dest='temp', action='store',
                    help='Template file to peform replacements on')
parser.add_argument('-D', dest='defs', action='append', default=[],
                    help='Manual definitions')
parser.add_argument("-i", dest='incls', action='append', default=[],
                    help='One or more JSON dictionaries defining insertions/replacements map')
parser.add_argument('-I', dest='incl_dirs', action='append', default=[],
                    help='Direcotry to look in for inclusions')
parser.add_argument('-C', dest='ctxs', action='append', default=[],
                    help='Select contexts available in dictoary files')
parser.add_argument('-W', dest='warnings', action='append', default=[],
                    help='Configure warnings. -Werror, -Wno-overwrite, -Wno-overwrite-context, -Wno-file-not-found, -Wno-define-fail')
parser.add_argument('-o', dest='out', action='store',
                    help='Output file')
parser.add_argument('-v', "--version", dest='version', action='store_const', const=1,
                    help='Prints the current version number')
parser.add_argument('-V', "--verbose", dest='verbose', action='store_const', const=1,
                    help='Include more verbose output')


if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

for arg in sys.argv:
    if "-v" in arg[0:2] or "--version" in arg[0:9]:
        print("Tempest version 0.1")
        sys.exit(0)

args = parser.parse_args()

if len(args.incls) == 0 and len(args.defs)==0:
    parser.print_help()
    print("\nError: must supply dictoary (-i) and/or manual definition(s) (-D)")
    sys.exit(1)

if args.out is None:
    args.out = args.temp + ".out"

dict      = load_dict(args.incls, args.incl_dirs, args.defs, args.ctxs)
template  = load_temp(args.temp)
result    = run_subs(template, dict)
write_out(result, args.out)
